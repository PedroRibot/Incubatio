#include "/Engine/Public/Platform.ush"

//#define  MAX_MARCHING_STEPS 255
//#define  MIN_DIST 0.0
//#define  MAX_DIST 100.0
//#define  EPSILON 0.0001

RWTexture2D<float3> RenderTarget;
Texture2D<float4> DataTexture;

////SamplerState DataSampler;
//float sphereSDF(float3 samplePoint)
//{
//    return length(samplePoint) - 1.0;
//}

//float sceneSDF(float3 samplePoint)
//{
//    return sphereSDF(samplePoint);
//}

//float shortestDistanceToSurface(float3 eye, float3 marchingDirection, float start, float end)
//{
//    float depth = start;
//    for (int i = 0; i < MAX_MARCHING_STEPS; i++)
//    {
//        float dist = sceneSDF(eye + depth * marchingDirection);
//        if (dist < EPSILON)
//        {
//            return depth;
//        }
//        depth += dist;
//        if (depth >= end)
//        {
//            return end;
//        }
//    }
//    return end;
//}

//float3 rayDirection(float fieldOfView, float2 size, float2 fragCoord)
//{
//    float2 xy = fragCoord - size / 2.0;
//    float z = size.y / tan(radians(fieldOfView) / 2.0);
//    return normalize(float3(xy, -z));
//}



 
#define MAX_DIST 1000.0
#define MIN_DIST 1.
#define MAX_MARCHING_STEPS 255
#define EPSILON 1.
#define OBJECT_COUNT 10

#define JOINT_COUNT 23
#define EDGE_COUNT 20

#define PI 3.14159265f

struct Surface
{
    float4 color;
    float ambientScale;
    float diffuseScale;
    float specularScale;
    float specularPow;
    float occlusionScale;
    float occlusionRange;
    float occlusionResolution;
    float3 occlusionColor;
    float signedDistance;
};

struct myjointvalues
{
    float3 color;
    float ambientScale;
    float diffuseScale;
    float specularScale;
    float specularPow;
    float occlusionScale;
    float occlusionRange;
    float occlusionResolution;
    float3 occlusionColor;

    int primitives[JOINT_COUNT];
    float4x4 transforms[JOINT_COUNT];
    float3 sizes[JOINT_COUNT];
    float roundings[JOINT_COUNT];
    float smoothings[JOINT_COUNT];
};

struct myedgevalues
{
    float3 color;
    float ambientScale;
    float diffuseScale;
    float specularScale;
    float specularPow;
    float occlusionScale;
    float occlusionRange;
    float occlusionResolution;
    float3 occlusionColor;

    int primitives[EDGE_COUNT];
    float4x4 transforms[EDGE_COUNT];
    float3 sizes[EDGE_COUNT];
    float roundings[EDGE_COUNT];
    float smoothings[EDGE_COUNT];
};

struct myobjectvalues
{
    float3 color;
    float ambientScale;
    float diffuseScale;
    float specularScale;
    float specularPow;
    float occlusionScale;
    float occlusionRange;
    float occlusionResolution;
    float3 occlusionColor;

    float3 frequency;
    float3 amplitude;
    float3 phase;

    int primitive;
    float4x4 transform;
    float3 size;
    float rounding;
    float smoothing;
};


struct myfunctions
{
    float4 myTime;
    float3 bgColor;
    float bg_on;
    float3 lightPosition;
    float jointEdgeSmoothing;
    float skelObjectSmoothing;
    float doShadow;
    float shadowStrength;
    float shadowSmooth;

    float fog_min_dist;
    float fog_max_dist;
    
    float sceneDepth;
    float dithering;

    myobjectvalues o[OBJECT_COUNT];
    myedgevalues e;
    myjointvalues j;
    
    //Distance field operators and usual maths functions.
    //Most of it comes from https://www.iquilezles.org and http://mercury.sexy

        // Return 2x2 rotation matrix
        // With floattor swizzle/mask can use as a 3x3 xform
        // For y, you need to invert 
        // angle in radians
    float2x2 Rot2(float a)
    {
        float c = cos(a);
        float s = sin(a);
        return float2x2(c, -s, s, c);
    }

        // http://www.songho.ca/opengl/gl_anglestoaxes.html

        // Return 4x4 rotation X matrix
        // angle in radians
    float4x4 Rot4X(float a)
    {
        float c = cos(a);
        float s = sin(a);
        return float4x4(1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1);
    }

        // Return 4x4 rotation Y matrix
        // angle in radians
    float4x4 Rot4Y(float a)
    {
        float c = cos(a);
        float s = sin(a);
        return float4x4(c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1);
    }

        // Return 4x4 rotation Z matrix
        // angle in radians
    float4x4 Rot4Z(float a)
    {
        float c = cos(a);
        float s = sin(a);
        return float4x4(
                c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
    }

    float4x4 RotAA(float3 axis, float angle)
    {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
            
        return float4x4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,
                        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,
                        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,
                        0.0, 0.0, 0.0, 1.0);
    }

        // Translate is simply: p - d
        // opTx will do transpose(m)
        // p' = m*p
        //    = [m0 m1 m2 m3 ][ p.x ]
        //      [m4 m5 m6 m7 ][ p.y ]
        //      [m8 m9 mA mB ][ p.z ]
        //      [mC mD mE mF ][ 1.0 ]
    float4x4 Loc4(float3 p)
    {
        p *= -1.;
        return float4x4(
                1, 0, 0, p.x,
                0, 1, 0, p.y,
                0, 0, 1, p.z,
                0, 0, 0, 1
            );
    }


        //// if no support for GLSL 1.2+
        ////     #version 120
        //float4x4 transposeM4(float4x4 m) {
        //	float4 r0 = m[0];
        //	float4 r1 = m[1];
        //	float4 r2 = m[2];
        //	float4 r3 = m[3];
        //
        //	float4x4 t = float4x4(
        //		float4(r0.x, r1.x, r2.x, r3.x),
        //		float4(r0.y, r1.y, r2.y, r3.y),
        //		float4(r0.z, r1.z, r2.z, r3.z),
        //		float4(r0.w, r1.w, r2.w, r3.w)
        //	);
        //	return t;
        //}

            // Rotation matrix around the X axis.
    float4x4 rotateX(float theta)
    {
        float c = cos(theta);
        float s = sin(theta);
        return float4x4(
                float4(1, 0, 0, 0),
                float4(0, c, -s, 0),
                float4(0, s, c, 0),
                float4(0, 0, 0, 1)
            );
    }

        // __ Smoothing functions _____________________________________

        // Smooth Min
        // http://www.iquilezles.org/www/articles/smin/smin.htm

        // Min Polynomial
    float sMinP(float a, float b, float k)
    {
        float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
        return lerp(b, a, h) - k * h * (1.0 - h);
    }

        // Min Exponential
    float sMinE(float a, float b, float k)
    {
        float res = exp(-k * a) + exp(-k * b);
        return -log(res) / k;
    }


    float sMaxE(float a, float b, float k)
    {
        float res = exp(k * a) + exp(k * b);

        return log(res) / k;

    }

        // Min Power
    float sMin(float a, float b, float k)
    {
        a = pow(a, k);
        b = pow(b, k);
        return pow((a * b) / (a + b), 1.0 / k);
    }

        // __ Surface Primitives ____________________________

        // Return max component x, y, or z
    float maxcomp(in float3 p)
    {
        return max(p.x, max(p.y, p.z));
    }

        // Signed

        // b.x = Width
        // b.y = Height
        // b.z = Depth
        // Leave r=0 if radius not needed
    float sdBox(float3 p, float3 b, float r)
    {
        float3 d = abs(p) - b;
        return min(maxcomp(d), 0.0) - r + length(max(d, 0.0));
            // Inlined maxcomp
            //return min(max(d.x,max(d.y,d.z)),0.0) - r + length(max(d,0.0));
    }


    float sdCappedCylinder(float3 p, float2 h)
    {
        float2 d = abs(float2(length(p.xz), p.y)) - h;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
    }


    float sdCapsule(float3 p, float3 a, float3 b, float r)
    {
        float3 pa = p - a, ba = b - a;
        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
        return length(pa - ba * h) - r;
    }

        // c.x Width
        // c.y Base Radius
        // c.z Depth
        // Note: c must be normalized
    float sdCone(float3 p, float3 c) // TODO: do we need to use 'in' for all primitives?
    {
        float q = length(p.xz);
        return dot(c.xy, float2(q, p.y));
    }


    float sdCylinder(float3 p, float3 c)
    {
        return length(p.xz - c.xy) - c.z;
    }

        // n.xyz = point on plane
        // n.w   = distance to plane
        // Note: N must be normalized!
    float sdPlane(float3 p, float4 n)
    {
        return dot(p, n.xyz) + n.w;
    }

        // 4 sided pyramid
        // h.x = base X
        // h.y = height
        // h.z = base Z (usually same as h.x)
    float sdPyramid4(float3 p, float3 h)
    {
        p.xz = abs(p.xz); // Symmetrical about XY and ZY
        float3 n = normalize(h);
        return sdPlane(p, float4(n, 0.0)); // cut off bottom
    }


    float sdSphere(float3 p, float r)
    {
        return length(p) - r;
    }


    float sdSphere2(float3 p, float r)
    {
        return abs(length(p) - r);
    }


    float sdTorus(float3 p, float2 t)
    {
        float2 q = float2(length(p.xy) - t.x, p.z);
        return length(q) - t.y;
    }

        // TODO: document/derive magic number 0.866025
    float sdTriPrism(float3 p, float2 h)
    {
        float3 q = abs(p);
        return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);
    }

        // Unsigned

        // Box
    float udBox(float3 p, float3 b)
    {
        return length(max(abs(p) - b, 0.0));
    }

        // Round Box
    float udRoundBox(float3 p, float3 b, float r)
    {
        return length(max(abs(p) - b, 0.0)) - r;
    }

        // __ Distance Operations _____________________________________

        // Basic
        // Op Union
    float opU(float d1, float d2)
    {
        return min(d1, d2);
    }

        // Op Union
    float4 opU2(float4 d1, float4 d2)
    {
        return min(d1, d2);
    }

        // Op Union
    float4 opU(float4 a, float4 b)
    {
        return lerp(a, b, step(b.x, a.x));
    }

    float2 opU(float2 a, float2 b)
    {
        return lerp(a, b, step(b.x, a.x));
    }

        // Op Subtraction
    float opS(float a, float b)
    {
        return max(-b, a); // BUG in iq's docs: -a, b
    }
        // Op Subtraction
    float4 opS(float4 a, float4 b)
    {
        return max(-b, a);
    }

        // Op Intersection
    float opI(float a, float b)
    {
        return max(a, b);
    }


        // Advanced
    float opBlend(float a, float b, float k)
    {
        return sMin(a, b, k);
    }

        // a angle
    float displacement(float3 p, float a)
    {
        return sin(a * p.x) * sin(a * p.y) * sin(a * p.z); // NOTE: Replace with your own!
    }


    float opDisplace(float3 p, float d1, float d2)
    {
        return d1 + d2;
    }

        // Op Union Translated
    float4 opUt(float4 a, float4 b, float fts)
    {
        float4 vScaled = float4(b.x * (fts * 2.0 - 1.0), b.yzw);
        return lerp(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));
    }


        // __ Domain Operations _______________________________________

        // NOTE: iq originally inlined the primitive inside the Domain operations. :-(
        // This implied that you would have needed to provide 
        // a primitive with one of the sd*() functions above
        // since we can't have a generic pointer to a function!
        // However we have moved them back out to the caller
        // for clarity and flexibility without general loss of precision.

        // Basic

    float mod(float x, float y)
    {
        return x - y * floor(x / y);
    }

    float3 mod3(float3 a, float3 b)
    {
        return float3(mod(a.x, b.x), mod(a.y, b.y), mod(a.z, b.z));

    }

        // Op Repetition
    float3 opRep(float3 p, float3 spacing)
    {

        float3 q = mod3(p + spacing * 0.5, spacing) - spacing * 0.5;

                //q = floor(p)*0.5 % -spacing + 0.5 * spacing; 
        return q;
    }

        // Deformations

        // Op Twist X
    float3 opTwistX(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.x);
        return float3(mul(m, p.yz), p.x);
    }

        // Op Twist Y
    float3 opTwistY(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.y);
        return float3(mul(m, p.xz), p.y);
    }

        // Op Twist Z
    float3 opTwistZ(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.z);
        return float3(mul(m, p.xy), p.z);
    }

        // iq's bend X
    float3 opCheapBend(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.y);
        float3 q = float3(mul(m, p.yx), p.z);
        return q;
    }

        // Op Cheap Bend X
    float3 opBendX(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.y);
        return float3(mul(m, p.yx), p.z);
    }

        // Op Cheap Bend Y
    float3 opBendY(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.z);
        return float3(mul(m, p.zy), p.x);
    }

        // Op Cheap Bend Z
    float3 opBendZ(float3 p, float angle)
    {
        float2x2 m = Rot2(angle * p.x);
        return float3(mul(m, p.xz), p.y);
    }

        // d = distance to move
    float3 opTrans(float3 p, float3 d)
    {
        return p - d;
    }

        // Note: m must already be inverted!
        // TODO: invert(m) transpose(m)
        // Op Rotation / Translation
    float3 opTx(float3 p, float4x4 m)
    { // BUG in iq's docs, should be q
        return (mul(transpose(m), float4(p, 1.0))).xyz;
    }

        // Op Scale
    float opScale(float3 p, float s)
    {
        return sdBox(p / s, float3(1.2, 0.2, 1.0), 0.01) * s; // TODO: FIXME: NOTE: replace with primative sd*()
    }


        //
        //                           HG_SDF
        //
        //     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS
        //
        //     version 2016-01-10
        //
        //     Check http://mercury.sexy/hg_sdf for updates
        //     and usage examples. Send feedback to spheretracing@mercury.sexy.
        //
        //     Brought to you by MERCURY http://mercury.sexy
        //
        //
        //
        // Released as Creative Commons Attribution-NonCommercial (CC BY-NC)

    void pR45(inout float2 p)
    {
        p = (p + float2(p.y, -p.x)) * sqrt(0.5);
    }


    float pMod1(inout float p, float size)
    {
        float halfsize = size * 0.5;
        float c = floor((p + halfsize) / size);
        p = fmod(p + halfsize, size) - halfsize;
        return c;
    }
    float fOpUnionColumns(float a, float b, float r, float n)
    {
        if ((a < r) && (b < r))
        {
            float2 p = float2(a, b);
            float columnradius = r * sqrt(2) / ((n - 1) * 2 + sqrt(2));
            pR45(p);
            p.x -= sqrt(2) / 2 * r;
            p.x += columnradius * sqrt(2);
            if (fmod(n, 2) == 1)
            {
                p.y += columnradius;
            }
                // At this point, we have turned 45 degrees and moved at a point on the
                // diagonal that we want to place the columns on.
                // Now, repeat the domain along this direction and place a circle.
            pMod1(p.y, columnradius * 2);
            float result = length(p) - columnradius;
            result = min(result, p.x);
            result = min(result, a);
            return min(result, b);
        }
        else
        {
            return min(a, b);
        }
    }


    float fOpUnionRound(float a, float b, float r)
    {
        float2 u = max(float2(r - a, r - b), float2(0, 0));
        return max(r, min(a, b)) - length(u);
    }

    float fOpIntersectionRound(float a, float b, float r)
    {
        float2 u = max(float2(r + a, r + b), float2(0, 0));
        return min(-r, max(a, b)) + length(u);
    }

    float fOpDifferenceRound(float a, float b, float r)
    {
        return fOpIntersectionRound(a, -b, r);
    }

    float fOpPipe(float a, float b, float r)
    {
        return length(float2(a, b)) - r;
    }


    float2 pModPolar(float2 p, float repetitions)
    {
        float angle = (2 * PI) / repetitions;
        float a = atan2(p.y, p.x) + angle / 2.;
        float r = length(p);
        float c = floor(a / angle);
        a = mod(a, angle) - angle / 2.;
        p = float2(cos(a), sin(a)) * r;
            // For an odd number of repetitions, fix cell index of the cell in -x direction
            // (cell index would be e.g. -5 and 5 in the two halves of the cell):
        if (abs(c) >= (repetitions / 2))
            c = abs(c);
        return p;
    }

        // Function to rotate a position by a quaternion by PEDRO
    float3 rotateByQuaternion(float3 v, float4 q)
    {
            // Quaternion math to rotate vector v by quaternion q
        float3 u = float3(q.x, q.y, q.z);
        float s = q.w;
        return 2.0 * dot(u, v) * u
                    + (s * s - dot(u, u)) * v
                    + 2.0 * s * cross(u, v);
    }

    float3 GetScaleFromMatrix(float4x4 m)
    {
        float scaleX = length(float3(m._11, m._21, m._31)); // Length of the first column for X scale
        float scaleY = length(float3(m._12, m._22, m._32)); // Length of the second column for Y scale
        float scaleZ = length(float3(m._13, m._23, m._33)); // Length of the third column for Z scale
        return float3(scaleX, scaleY, scaleZ);
    }

    float3x3 QuatToMat(float4 q)
    {
        float qx = q.x;
        float qy = q.y;
        float qz = q.z;
        float qw = q.w;
            
        float3x3 m;
        m[0][0] = 1.0 - 2.0 * qy * qy - 2.0 * qz * qz;
        m[0][1] = 2.0 * qx * qy - 2.0 * qz * qw;
        m[0][2] = 2.0 * qx * qz + 2.0 * qy * qw;
        m[1][0] = 2.0 * qx * qy + 2.0 * qz * qw;
        m[1][1] = 1.0 - 2.0 * qx * qx - 2.0 * qz * qz;
        m[1][2] = 2.0 * qy * qz - 2.0 * qx * qw;
        m[2][0] = 2.0 * qx * qz - 2.0 * qy * qw;
        m[2][1] = 2.0 * qy * qz + 2.0 * qx * qw;
        m[2][2] = 1.0 - 2.0 * qx * qx - 2.0 * qy * qy;
            
        return m;
    }

    float2 rotate2D(float2 v, float a)
    {
        return float2(cos(a) * v.x + sin(a) * v.y, -sin(a) * v.x + cos(a) * v.y);
    }

        // Rotation matrix around arbitrary axis
    float4x4 rotateAxis(float3 axis, float angle)
    {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
            
        return float4x4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,
                        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,
                        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,
                        0.0, 0.0, 0.0, 1.0);
    }

    float3 rotatePt(float3 pt, float3 axis, float angle)
    {
        float4x4 m = rotateAxis(axis, angle);
        return mul(m, float4(pt, 1.0)).xyz;
    }


        //FRACTALS -----------------
        // ShaderToy

    float merger(in float3 z)
    {
        float3 offset = float3(0.92858, 0.92858, 0.32858);
        float scale = 3.0;
        const int iterations = 7;

            // Folding 'tiling' of 3D space;
        z = abs(1.0 - mod(z.x, 2.0));

        float d = 1000.0;
        for (int n = 0; n < iterations; n++)
        {
            z.xy = rotate2D(z.xy, 4.0 + 2.0 * cos(myTime.y / 8.0));
            z = abs(z);
            if (z.x < z.y)
            {
                z.xy = z.yx;
            }
            if (z.x < z.z)
            {
                z.xz = z.zx;
            }
            if (z.y < z.z)
            {
                z.yz = z.zy;
            }
            z = scale * z - offset * (scale - 1.0);
            if (z.z < -0.5 * offset.z * (scale - 1.0))
                z.z += offset.z * (scale - 1.0);
            d = min(d, length(z) * pow(scale, float(-n) - 1.0));
        }
            
        return d - 0.001;
    }

    float sierpinskiPyramid(float3 pt)
    {
        float3 ori = float3(0.0, 2.5, 0.0);
        float3 a1 = float3(1, 1, 1) + ori;
        float3 a2 = float3(-1, -1, 1) + ori;
        float3 a3 = float3(1, -1, -1) + ori;
        float3 a4 = float3(-1, 1, -1) + ori;
            
        float3 c;
        int n = 0;
        float dist, d;
        float scale = 2.;
        while (n < 16)
        {
            c = a1;
            dist = length(pt - a1);
            d = length(pt - a2);
            if (d < dist)
            {
                c = a2;
                dist = d;
            }
            d = length(pt - a3);
            if (d < dist)
            {
                c = a3;
                dist = d;
            }
            d = length(pt - a4);
            if (d < dist)
            {
                c = a4;
                dist = d;
            }
            pt = scale * pt - c * (scale - 1.0);
            n++;
        }
            
        return length(pt) * pow(scale, float(-n));
    }

    float sierpinskiPyramidFold(float3 pt)
    {
        float r;
        float offset = 1.;
        float scale = 2.;
        pt.y -= 2.5;
        int n = 0;
        while (n < 15)
        {
            if (pt.x + pt.y < 0.)
                pt.xy = -pt.yx;
            if (pt.x + pt.z < 0.)
                pt.xz = -pt.zx;
            if (pt.y + pt.z < 0.)
                pt.zy = -pt.yz;
            pt = pt * scale - offset * (scale - 1.0);
            n++;
        }
            
        return (length(pt) * pow(scale, -float(n)));
    }

    float mengerSponge(float3 pt)
    {
        float scale = 1.0;
        float offset = -2.;
        float iterations = 3.;

        float dist = boxSDF(float3(pt.x, pt.y + offset, pt.z), float3(scale, scale, scale));
            
        float s = 1.;
            
        float da, db, dc;
            
        for (int i = 0; i < 4; i++)
        {
            float3 a = fmod(pt * s, 2.0) - 1.0;
            s *= iterations;
            float3 r = abs(1.0 - 3.0 * abs(a));
                
            da = max(r.x, r.y);
            db = max(r.y, r.z);
            dc = max(r.z, r.x);
                
            float c = (min(da, min(db, dc)) - 1.) / s;
            if (c > dist)
                dist = c;
        }
            
        return dist;
    }

    float alteredMenger(float3 pt)
    {
        float scale = 1.0;
        float offset = -2.;
        float iterations = 3.;

        float dist = boxSDF(float3(pt.x, pt.y + offset, pt.z), float3(scale, scale, scale));
            
        float s = 2.;
            
        float da, db, dc;
            
        for (int i = 0; i < 4; i++)
        {
            float3 a = mod(mul(pt, float3(s, s, s)), 2.0) - 1.0;
            s *= iterations;
            float3 r = abs(1.0 - 3.0 * abs(a));
                
            r = mul(float4(r, 1.0), rotateX(20.)).xyz;
            da = max(r.x + 1.5, r.y);
            r = mul(float4(r, 1.0), rotateX(80.)).xyz;
                
            da = max(da + r.x - 0.5, r.y);
            db = max(r.y, r.z);
            dc = max(r.z + 0.5, r.x);
                
            float c = (min(da, min(db, dc)) - 1.) / s;
            if (c > dist)
                dist = c;
        }
            
        return dist;
    }

    float evolvingFractal(float3 pt)
    {
        //vec3 off = vec3(0.7, 0.5, 0.15);
        //vec3 off = vec3(0.5, 0.85, 1.25);
        float3 off = float3(1., 1., 1.);
        float scale = 2.;
        pt.y -= 2.5;
        int n = 0;

        while (n < 18)
        {
            //pt = rotatePt(pt, vec3(1.), 31.); // snowflake
            pt = rotatePt(pt, float3(1, 1, 1), cos(10. + myTime.y * 0.1));
            
            pt = abs(pt); // for cube
            
            if (pt.x + pt.y < 0.)
                pt.xy = -pt.yx;
            if (pt.x + pt.z < 0.)
                pt.xz = -pt.zx;
            if (pt.y + pt.z < 0.)
                pt.zy = -pt.yz;
            
            pt = rotatePt(pt, float3(0.35, 0.2, 0.3), -90. + myTime.y * 0.1);
            
            pt.x = pt.x * scale - off.x * (scale - 1.0);
            pt.y = pt.y * scale - off.y * (scale - 1.0);
            pt.z = pt.z * scale - off.z * (scale - 1.0);
            
            pt = rotatePt(pt, float3(0.3, 0.1, 0.25), -70. + myTime.y * 0.1);
            
            n++;
        }
        return (length(pt) * pow(scale, -float(n)));
    }

    float evolvingFractal2(float3 pt)
    {
        float3 off = float3(1.25, 1.25, 1.25);
        float scale = 2.;
        pt.y -= 2.5;
        int n = 0;

        while (n < 18)
        {
            //pt = rotatePt(pt, vec3(1.), 31.); // snowflake
            pt = rotatePt(pt, float3(1., 1., 1.), sin(0. + myTime.y * 0.1));
            
            pt = abs(pt); // for cube
            
            if (pt.x + pt.y < 0.)
                pt.xy = -pt.yx;
            if (pt.x + pt.z < 0.)
                pt.xz = -pt.zx;
            if (pt.y + pt.z < 0.)
                pt.zy = -pt.yz;
            
            pt = rotatePt(pt, float3(0.35, 0.2, 0.3), -90. + myTime.y * 0.1);
            
            pt.x = pt.x * scale - off.x * (scale - 1.0);
            pt.y = pt.y * scale - off.y * (scale - 1.0);
            pt.z = pt.z * scale - off.z * (scale - 1.0);
            
            pt = rotatePt(pt, float3(0.3, 0.1, 0.25), -70. + myTime.y * 0.1);
            
            n++;
        }
        return (length(pt) * pow(scale, -float(n)));
    }

    float julia(float3 pos, float3 scale)
    {
        int iter_count = int(scale.y);
        float delta = scale.z;


        //float delta = sin(vectorTime.y / 2.0) / 4.0;
        float4 c = float4(-0.2, -.6, delta, 0.0);
        float4 z = float4(pos, 0.0);
        float4 nz;

        float dr2 = 1.0;
        float r2 = dot(z, z);

        for (int i = 0; i < iter_count; i++)
        {
            dr2 *= scale.x * r2;
            nz.x = z.x * z.x - dot(z.yzw, z.yzw);
            nz.yzw = scale.x / 2.0 * z.x * z.yzw;

            z = nz + c;

            r2 = dot(z, z);
            if (r2 > 4.0)
            {
                break;
            }
        }

        return 0.25 * sqrt(r2 / dr2) * log(r2);
    }

    //FROM UNITY Paul Hubert
    float truchetTower(float3 p, float r)
    {

        float rnd = frac(sin(dot(floor(p) + 41., float3(7.63, 157.31, 113.97))) * 43758.5453);

        if (rnd > .75)
            p = 1. - p;
        else if (rnd > .5)
            p = p.yzx;
        else if (rnd > .25)
            p = p.zxy;

        p = frac(p);

        // Draw three toroidal shapes within the unit block, oriented in such a way to form a 3D tile.
        // It can be a little frustrating trying to get the orientaion right, but once you get the hang
        // of it, it really is pretty simple. If you're not sure what's going on, have a look at the 
        // picture in the link provided above. By the way, the following differs a little from the
        // standard torii distance equations on account of slight mutations, cost cutting, etc, but 
        // that's what it all essentially amounts to.  
        
        // Toroidal shape one.
        float3 q = p; // Not rotated.
        q.xy = length(float2(length(q.xy), q.z) - .5) + .175; // The "abs" and ".125" are additions, in this case.          ------REPLACE LENGTH BY ABS FOR SHARP VERSION
        rnd = dot(q.xy, q.xy); // Reusing the "rnd" variable. Squared distance.

        // Toroidal shape two. Same as above, but rotated and shifted to a different part of the cube. 
        q = p.yzx - float3(1, 1, 0);
        q.xy = length(float2(length(q.xy), q.z) - .5) + .175;
        rnd = min(rnd, dot(q.xy, q.xy)); // Minimum of shape one and two.
        
        // Toroidal shape three. Same as the two above, but rotated and shifted to a different part of the cube.
        q = p.zxy - float3(0, 1, 0);
        q.xy = length(float2(length(q.xy), q.z) - .5) + .175;
        rnd = min(rnd, dot(q.xy, q.xy)); // Minimum of of all three.
                
        return sqrt(rnd) - r; // Taking the square root and setting tube radius... kind of.

    }



    float apollonian1(float3 p, float aF1)
    {
        float scale = 1;
        float4 orb = float4(1000, 1000, 1000, 1000);
        
        for (int i = 0; i < 8; i++)
        {
            p = -1.0 + 2.0 * frac(0.5 * p + 0.5);
            float r2 = dot(p, p);
            orb = min(orb, float4(abs(p), r2));
            float k = aF1 / r2;
            p *= k;
            scale *= k;
        }
        float res = min(abs(p.z) + abs(p.x),
                min(abs(p.x) + abs(p.y),
                    abs(p.y) + abs(p.z)));
        
        return 0.25 * res / scale;
    }




    float4 apollonianColor(float3 p)
    {
        float scale = 1;
        float4 orb = float4(1000, 1000, 1000, 1000);
        float r2;
        for (int i = 0; i < 10; i++)
        {
            p = -1.0 + 2.0 * frac(0.5 * p + 0.5);
            r2 = dot(p, p);
            orb = min(orb, float4(abs(p), r2));
            float k = 1.2 / r2;
            p *= k;
            scale *= k;
        }
        float res = min(abs(p.z) + abs(p.x),
                max(abs(p.x) + abs(p.y),
                    abs(p.y) + abs(p.z)));

        float3 color = float3(r2, scale / 100, 0);
        return float4(color, 0.25 * res / scale);
    }


    float forks(float3 p)
    {
        float s = 0.1;
        float scale = 1;

        float tt = 0.45 + (sin(myTime.x * 2.) * .5 + .5) * .65;
        
        tt = 0.5;
        
        float4 orb = float4(1000.0, 1000.0, 1000.0, 1000.0);
        
        for (int i = 0; i < 8; i++)
        {
            p = -1.0 + 2.0 * frac(0.5 * p + 0.5);

            float r2 = dot(p, p);
            
            
            r2 = r2 * tt + max(abs(p.x), max(abs(p.y), abs(p.z))) * (1.0 - tt);
            
            orb = min(orb, float4(abs(p), r2));
            
            float k = s / r2;
            p *= k;
            scale *= k;
        }
        
        return 0.25 * abs(p.y) / scale;
    }

    float3 fold(float3 p, float3 n)
    {
        return p -= 2.0 * min(0.0, dot(p, n)) * n;
    }


    float tetraFold(float3 p, float aF0, float aF1, float aF2, float aF3)
    {
        float SCALE = 2;
        float3 c;
        int n = 0;
        int IT = 8;
        float ic = 0;
        float4x4 mat;
        float3 Offset = float3(1, 1, 1);

        aF0 = radians(aF0);
        aF1 = radians(aF1);
        aF2 = radians(aF2);
        aF3 = radians(aF3);


        while (n < IT)
        {


            if (p.x - p.y < 0)
                p.xy = p.yx;
            if (p.x - p.z < 0)
                p.xz = p.zx;
            if (p.y - p.z < 0)
                p.yz = p.zy;
            if (p.x + p.y < 0)
                p.xy = -p.yx;
            if (p.x + p.z < 0)
                p.xz = -p.zx;
            if (p.y + p.z < 0)
                p.yz = -p.zy;
            mat = Rot4Y(aF0);
            p = mul(mat, float4(p, 1.0)).xyz;
            p = p * SCALE - Offset * (SCALE - 1);
            
            mat = Rot4Y(aF1);
            p = mul(mat, float4(p, 1.0)).xyz;
            n++;
        }

        float res = (length(p) - 2) * pow(SCALE, -n);
        return res;
    }


    float cubeFold(float3 p, float aF0, float aF1, float aF2)
    {
        float SCALE = aF2;
        float3 c;
        int n = 0;
        int IT = 11;
        float ic = 0;
        float4x4 mat;
        float3 Offset = float3(1, 1, 1);

        aF0 = radians(aF0);
        aF1 = radians(aF1);


        while (n < IT)
        {


            p.x = abs(p.x);

            p.y = abs(p.y);

            p.z = abs(p.z);

            mat = Rot4Y(aF1);
            p = mul(mat, float4(p, 1.0)).xyz;

            p = p * SCALE - Offset * (SCALE - 1);

            mat = Rot4X(aF0);
            p = mul(mat, float4(p, 1.0)).xyz;

            n++;
        }

        float res = (length(p) - 2) * pow(SCALE, -n);
        return res;
    }


    float cubeFold(float3 p)
    {
        float SCALE = 2.1;
        float3 c;
        int n = 0;
        int IT = 10;
        float ic = 0;
        
        float3 Offset = float3(1, 1, 1);
        while (n < IT)
        {

            float4x4 mat = RotAA(float3(0, 1, 1), 2 * myTime.x);
            p = mul(mat, float4(p, 1.0)).xyz;;
            
            if (p.x < 0)
            {
                p.x = abs(p.x);
                ic++;
            }
            if (p.y < 0)
            {
                p.y = abs(p.y);
                ic++;
            }
            if (p.z < 0)
            {
                p.z = abs(p.z);
                ic++;
            }
            p = p * SCALE - Offset * (SCALE - 1);

            n++;
        }

        float res = (length(p) - 2) * pow(SCALE, -n);
        return res;
    }


    float octaFold(float3 p)
    {
        float SCALE = 2.1;
        float3 oldP = p;
        float3 c;
        int n = 0;
        int IT = 18;

        float4x4 mat = RotAA(float3(-1, 1, -1), -2 * myTime.x);
        p = mul(mat, float4(p, 1.0)).xyz;

        float3 Offset = float3(1, 1.5, 1);
        while (n < IT)
        {
            mat = RotAA(float3(-1, 1, -1), 2 * myTime.x);
            p = mul(mat, float4(p, 1.0)).xyz;

            p = abs(p);

            if (p.x - p.y < 0)
                p.xy = p.yx; // fold 1

            if (p.x - p.z < 0)
                p.xz = p.zx; // fold 2

            if (p.y - p.z < 0)
                p.zy = p.yz; // fold 3       
            p = p * SCALE - Offset * (SCALE - 1);
            mat = RotAA(float3(1, -1, 1), 1 * myTime.x);
            p = mul(mat, float4(p, 1.0)).xyz;;
            n++;
        }

        float res;
        res = (length(p) - 2) * pow(SCALE, -n);
        
        return res;
    }

    float2 octaFold2(float3 p)
    {
        float SCALE = 3;
        float3 c;
        int n = 0;
        int IT = 8;
        float val = 0;

        float t = 0.1 * myTime.y;
        float4x4 rot = RotAA(float3(0, 1, 0), -t * PI / 4);
        p = mul(rot, float4(p, 1.0)).xyz;

        float3 Offset = float3(1, 1, 0.5);
        while (n < IT)
        {
            
            float4x4 mat = RotAA(float3(0, 1, 0), t * PI / 4);

            p = mul(mat, float4(p, 1.0)).xyz;

            if (p.x < 0)
            {
                p.x = -p.x;
                val++;
            }
            if (p.y < 0)
            {
                p.y = -p.y;
                val++;
            }
            if (p.z < 0)
            {
                p.z = -p.z;
                val++;
            }

            if (p.x - p.y < 0)
            {
                p.xy = p.yx;
                val++;
            }
            if (p.x - p.z < 0)
            {
                p.xz = p.zx;
                val++;
            }
            if (p.y - p.z < 0)
            {
                p.zy = p.yz;
                val++;
            }

            p.x = p.x * SCALE - Offset.x * (SCALE - 1);
            p.y = p.y * SCALE - Offset.y * (SCALE - 1);
            p.z = p.z * SCALE;

            if (p.z > 0.5 * Offset.z * (SCALE - 1))
                p.z = p.z - Offset.z * (SCALE - 1);

            mat = RotAA(float3(1, 0, 0), PI / 2);
            p = mul(mat, float4(p, 1.0)).xyz;;
            n++;
        }
        
        val = val / (6 * IT);

        float res = (length(p) - 2) * pow(SCALE, -n);
        
        return float2(res, val);
    }

    // float octaFold(float3 p, float algoFloat0, float algoFloat1, float algoFloat2, float algoFloat3)
    // {
    //     float SCALE = 2.1;
    //     float3 oldP = p;
    //     float3 c;
    //     int n = 0;
    //     int IT = 10;

    //     float4x4 mat = RotAA(float3 (-1,1,-1),-algoFloat0);
    //             p=mul(mat,float4(p, 1.0)).xyz;

    //     float3 Offset = float3(1,1.5,1);
    //     while (n < IT) 
    //     {
    //         mat = RotAA(float3 (-1,1,-1), algoFloat0);
    //         p=mul(mat,float4(p, 1.0)).xyz;

    //         p = abs(p);

    //         if(p.x-p.y<0) p.xy = p.yx; // fold 1

    //         if(p.x-p.z<0) p.xz = p.zx; // fold 2

    //         if(p.y-p.z<0) p.zy = p.yz; // fold 3       
    //         p = p * SCALE - Offset * (SCALE-1);
    //         mat = RotAA(float3 (1,-1,1), algoFloat1);
    //         p=mul(mat,float4(p, 1.0)).xyz;
    //         n++;
    //     }

    //     float res;
    //     res= (length(p)-2) * pow(SCALE, -n);
        
    //     return  res;
    // }


    float RoundBox(float3 p, float3 csize, float offset)
    {
        float3 di = abs(p) - csize;
        float k = max(di.x, max(di.y, di.z));
        return abs(k * float(k < 0.) + length(max(di, 0.0)) - offset);
    }

    float Thingy(float3 p, float e)
    {
        float3 Offset = float3(0, 0, 0);
        p -= Offset;
        return (abs(length(p.xy) * p.z) - e) / sqrt(dot(p, p) + abs(e));
    }

    float Thing2(float3 p)
    {
        int MI = 12;
        float3 CSize = float3(0.92436, 1.21212, 1.0101);
    //Just scale=1 Julia box
        float DEfactor = 1;
        float3 ap = p + 1;
        float4 orbitTrap = float4(0, 0, 0, 0);
        float Size = 1.14664;
        float3 C = float3(0.28572, 0.3238, -0.05716);
        float3 Offset = float3(0.88888, 0.4568, 0.03704);
        float DEoffset = 0;
        if (!(ap.x == p.x && ap.y == p.y && ap.z == p.z))
        {
            for (int i = 0; i < MI; i++)
            {
                ap = p;
                p = 2. * clamp(p, -CSize, CSize) - p;
        
                float r2 = dot(p, p);
                orbitTrap = min(orbitTrap, abs(float4(p, r2)));
                float k = max(Size / r2, 1.);

                p *= k;
                DEfactor *= k;
        
                p += C;
                orbitTrap = min(orbitTrap, abs(float4(p, dot(p, p))));
            }
        }
        //Call basic shape and scale its DE
        //return abs(0.5*Thingy(p,TThickness)/DEfactor-DEoffset);
        
        //Alternative shape
        //return abs(0.5*RoundBox(p, float3(1.,1.,1.), 1.0)/DEfactor-DEoffset);
        //Just a plane
        return abs(0.5 * abs(p.z - Offset.z) / DEfactor - DEoffset);
    }

    float kaliBox(float3 pos)
    {

        float3 Trans = float3(0.0365, -1.8613, 0.0365);
        float3 Julia = float3(-0.6691, -1.3028, -0.45775);
        float scale = 2.04348; //SCALED UNREAL
        float4 orbitTrap = float4(0, 0, 0, 0);
        float MinRad2 = 0.3492;
        int Iterations = 15;
        float absScalem1 = abs(scale - 1.0);

        float AbsScaleRaisedTo1mIters = pow(abs(scale), float(1 - Iterations));
            
        float4 p = float4(pos, 1), p0 = float4(Julia, 1); // p.w is the distance estimate
        
        for (int i = 0; i < Iterations; i++)
        {

            p.xyz = abs(p.xyz) + Trans;
            float r2 = dot(p.xyz, p.xyz);
            if (i < 2)
                orbitTrap = min(orbitTrap, abs(float4(p.xyz, r2)));
            p *= clamp(max(MinRad2 / r2, MinRad2), 0.0, 1.0); // dp3,div,max.sat,mul
            p = p * scale + p0;
        
        }
        return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
    }

    float mandelbulbSDF(float3 p, float power)
    {
        float3 w = p;
        float m = dot(w, w);
        float dz = 1.0;

        for (int i = 0; i < 3; i++)
        {
            dz = power * pow(sqrt(m), power - 1.0) * dz + 1.0;

            float r = length(w);
            float b = power * acos(w.y / r);
            float a = power * atan2(w.x, w.z);
            w = p + pow(r, power) * float3(sin(b) * sin(a), cos(b), sin(b) * cos(a));

            m = dot(w, w);
            if (m > 256.0)
                break;
        }

        return 0.25 * log(m) * sqrt(m) / dz;
    }

    float mandelbulb(float3 p)
    {
        float3 c = p;
        float r = length(c);
        float dr = 1;
        float xr = 0;
        float theta = 0;
        float phi = 0;

        for (int i = 0; i < 4 && r < 3; i++)
        {
            xr = pow(r, 7);
            dr = 6 * xr * dr + 1;
            theta = atan2(c.y, c.x) * 8;
            phi = asin(clamp(c.z / r, -1, 1)) * 8 - myTime.y;
            r = xr * r;
            c = r * float3(cos(phi) * cos(theta), cos(phi) * sin(theta), sin(phi));
        
            c += p;
            r = length(c);
        }

        return 0.35 * log(r) * r / dr;
    }

    float mandelbulb_v2(float3 p, float3 scale) //PRESET 450
    {
        float3 c = p;
        float r = length(c);
        float dr = 1;
        float xr = 0;
        float theta = 0;
        float phi = 0;

        for (int i = 0; i < 4 && r < 3; i++)
        {
            xr = pow(r, 7);
            dr = 6 * xr * dr + 1;
            theta = atan2(c.y, c.x) * (scale.x + 1.0);
            phi = asin(clamp(c.z / r, -1, 1)) * (scale.y + 1.0) - myTime.y / 10.0;
            r = xr * r;
            c = r * float3(cos(phi) * cos(theta), cos(phi) * sin(theta), sin(phi));
        
            c += p;
            r = length(c);
        }

        return 0.35 * log(r) * r / dr;
    }

    // float mandelbulb_v2( float3 p, float power, float phase ) {
    //     float3 w = p;
    //     float m = dot(w,w);
    //     float dz = 1.0;

    //     for( int i=0; i<3; i++ )
    //     {
    //         dz = power*pow(sqrt(m), power - 1.0 )*dz + 100.0;

    //         float r = length(w);
    //         float b = power*acos( w.y/r);
    //         float a = power*atan2( w.x, w.z );
    //         w = p + pow(r,power) * float3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );

    //         m = dot(w,w);
    //         if( m > 256.0 )
    //             break;
    //     }

    //     return 0.25*log(m)*sqrt(m)/dz;
    // }



        //COMPILE
        
        // float domainWarp(float3 p)
        // {


        //     float   res = perlin3(p);
        //     res = res + fbm3iq(8*p)/8;

        //     return res * 0.8;

        // }

    ///-------------------------------------




    // polynomial smooth
    float poly_smin(float a, float b, float k)
    {
        float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
        return lerp(b, a, h) - k * h * (1.0 - h);
    }

    // polynomial smooth min which returns both signed distance and interpolation factor
    float2 poly_smin_surface(float a, float b, float k)
    {
        float h = max(k - abs(a - b), 0.0) / k;
        float m = h * h * 0.5;
        float s = m * k * (1.0 / 2.0);
        return (a < b) ? float2(a - s, m) : float2(b - s, 1.0 - m);
    }

    Surface union_surface(in Surface surface1, in Surface surface2, in float smoothness)
    {
        float2 sd = poly_smin_surface(surface1.signedDistance, surface2.signedDistance, smoothness);

        Surface mySurface;

        mySurface.signedDistance = sd[0];
        float interpol = sd[1];
        mySurface.color = lerp(surface1.color, surface2.color, interpol);
        mySurface.ambientScale = lerp(surface1.ambientScale, surface2.ambientScale, interpol);
        mySurface.diffuseScale = lerp(surface1.diffuseScale, surface2.diffuseScale, interpol);
        mySurface.specularScale = lerp(surface1.specularScale, surface2.specularScale, interpol);
        mySurface.specularPow = lerp(surface1.specularPow, surface2.specularPow, interpol);
        mySurface.occlusionScale = lerp(surface1.occlusionScale, surface2.occlusionScale, interpol);
        mySurface.occlusionRange = lerp(surface1.occlusionRange, surface2.occlusionRange, interpol);
        mySurface.occlusionResolution = lerp(surface1.occlusionResolution, surface2.occlusionResolution, interpol);
        mySurface.occlusionColor = lerp(surface1.occlusionColor, surface2.occlusionColor, interpol);

        return mySurface;
    }

    float sceneSDF(float3 pos)
    {

        float distJoints = 1000.0;

        for (int jI = 0; jI < JOINT_COUNT; ++jI)
        {
            if (j.primitives[jI] < 0)
            {
                //Do nothing
            }
            else if (j.primitives[jI] == 0) // sphere
            {
                distJoints = poly_smin(distJoints, sphereSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].x), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 1) // box
            {
                distJoints = poly_smin(distJoints, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI], j.roundings[jI]), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 2) // capsule
            {
                distJoints = poly_smin(distJoints, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].z, j.sizes[jI].x, j.roundings[jI]), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 3) // cylinder
            {
                distJoints = poly_smin(distJoints, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].z, j.sizes[jI].x, j.roundings[jI]), j.smoothings[jI]);
            }
        }

        float distEdges = 1000.0;
    

        for (int eI = 0; eI < EDGE_COUNT; ++eI)
        {
            
            if (e.primitives[eI] < 0)
            {
                //Do nothing
            }
            else if (e.primitives[eI] == 0) // sphere
            {
                distEdges = poly_smin(distEdges, sphereSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].x), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 1) // box
            {
                // Does not work
                distEdges = poly_smin(distEdges, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI], e.roundings[eI]), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 2) // capsule
            {
                distEdges = poly_smin(distEdges, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].z, e.sizes[eI].x, e.roundings[eI]), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 3) // cylinder
            {
                distEdges = poly_smin(distEdges, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].z, e.sizes[eI].x, e.roundings[eI]), e.smoothings[eI]);
            }

        }

        float distObjects = 1000.0;

        for (int oI = 0; oI < OBJECT_COUNT; ++oI)
        {
            if (o[oI].primitive < 0)
            {
                //Do Nothing
            }
            else if (o[oI].primitive == 0) // sphere
            {
                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, sphereSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.x), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleSphereSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.x, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }

                
            }
            else if (o[oI].primitive == 1) // box
            {
                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size, o[oI].rounding), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleBoxSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size, o[oI].rounding, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }
            }
            else if (o[oI].primitive == 2) // capsule
            {
                distObjects = poly_smin(distObjects, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding), o[oI].smoothing); //________________________________________________ COPYYYYY------------------------------
            }
            else if (o[oI].primitive == 3) // cylinder
            {

                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleCylinderSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }
            }
            else if (o[oI].primitive == 4) // truchetTower (nothing) CHECK WITH DANI
            {
                distObjects = poly_smin(distObjects, truchetTower(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.z * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 5) // apollonian1 OK BIT NOISY
            {
                distObjects = poly_smin(distObjects, apollonian1(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.z * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 6) // Thing2 OK
            {
                distObjects = poly_smin(distObjects, Thing2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 7) // kaliBox (CANNOT SEE A THING) scaled 10 more here
            {
                distObjects = poly_smin(distObjects, kaliBox(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 8) // mandelbulb OK
            {
                distObjects = poly_smin(distObjects, mandelbulb_v2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.002, o[oI].size * 0.01), o[oI].smoothing) / 0.002;
            }
            else if (o[oI].primitive == 9) // merger   scaled 10 more here mmmm what is it suppose to do
            {
                distObjects = poly_smin(distObjects, merger(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 10) // sierpinskiPyramid ok
            {
                distObjects = poly_smin(distObjects, sierpinskiPyramid(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 11) // mengerSponge OK
            {
                distObjects = poly_smin(distObjects, mengerSponge(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 12) // alteredMenger  scaled 10 more here ???
            {
                distObjects = poly_smin(distObjects, alteredMenger(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 13) // evolvingFractal OK
            {
                distObjects = poly_smin(distObjects, evolvingFractal(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 14) // evolvingFractal2 OK
            {
                distObjects = poly_smin(distObjects, evolvingFractal2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 15) // OCTAFOLD COMMENTED
            {
                distObjects = poly_smin(distObjects, mandelbulbSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.x * 0.01), o[oI].smoothing) / 0.01;
                // distObjects = poly_smin( distObjects, octaFold(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.008), o[oI].smoothing )/ 0.008; 
            }
            else if (o[oI].primitive == 16) // julia ok??
            {
                distObjects = poly_smin(distObjects, julia(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size * 0.01), o[oI].smoothing) / 0.01;
            }
        }

        // return distObjects;


        float distJointsEdges = poly_smin(distJoints, distEdges, jointEdgeSmoothing);
        float dist;

        if (distObjects < 1000.0)
        {
            dist = poly_smin(distJointsEdges, distObjects, skelObjectSmoothing);
        }
        else
        {
            dist = distJointsEdges;
        }
        return dist;

    }

    Surface sceneSDF_surface(float3 pos)
    {
    
        // skeleton joints
        float distJoints = 1000.0;
        
        for (int jI = 0; jI < JOINT_COUNT; ++jI)
        {
            if (j.primitives[jI] < 0)
            {
                //Do nothing
            }
            else if (j.primitives[jI] == 0) // sphere
            {
                distJoints = poly_smin(distJoints, sphereSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].x), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 1) // box
            {
                distJoints = poly_smin(distJoints, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI], j.roundings[jI]), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 2) // capsule
            {
                distJoints = poly_smin(distJoints, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].z, j.sizes[jI].x, j.roundings[jI]), j.smoothings[jI]);
            }
            else if (j.primitives[jI] == 3) // cylinder
            {
                distJoints = poly_smin(distJoints, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, j.transforms[jI]), j.sizes[jI].z, j.sizes[jI].x, j.roundings[jI]), j.smoothings[jI]);
            }
        }
        
        Surface jointSurface;
        jointSurface.color = float4(j.color, 1.0);
        jointSurface.ambientScale = j.ambientScale;
        jointSurface.diffuseScale = j.diffuseScale;
        jointSurface.specularPow = j.specularPow;
        jointSurface.specularScale = j.specularScale;
        jointSurface.occlusionScale = j.occlusionScale;
        jointSurface.occlusionRange = j.occlusionRange;
        jointSurface.occlusionResolution = j.occlusionResolution;
        jointSurface.occlusionColor = j.occlusionColor;
        jointSurface.signedDistance = distJoints;
        
        // skeleton edges
        float distEdges = 1000.0;
        
        for (int eI = 0; eI < EDGE_COUNT; ++eI)
        {
            
            if (e.primitives[eI] < 0)
            {
                //Do nothing
            }
            else if (e.primitives[eI] == 0) // sphere
            {
                distEdges = poly_smin(distEdges, sphereSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].x), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 1) // box
            {
                // Does not work
                distEdges = poly_smin(distEdges, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI], e.roundings[eI]), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 2) // capsule
            {
                distEdges = poly_smin(distEdges, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].z, e.sizes[eI].x, e.roundings[eI]), e.smoothings[eI]);
            }
            else if (e.primitives[eI] == 3) // cylinder
            {
                distEdges = poly_smin(distEdges, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, e.transforms[eI]), e.sizes[eI].z, e.sizes[eI].x, e.roundings[eI]), e.smoothings[eI]);
            }

        }
        
        Surface edgeSurface;
        edgeSurface.color = float4(e.color, 1.0);
        edgeSurface.ambientScale = e.ambientScale;
        edgeSurface.diffuseScale = e.diffuseScale;
        edgeSurface.specularPow = e.specularPow;
        edgeSurface.specularScale = e.specularScale;
        edgeSurface.occlusionScale = e.occlusionScale;
        edgeSurface.occlusionRange = e.occlusionRange;
        edgeSurface.occlusionResolution = e.occlusionResolution;
        edgeSurface.occlusionColor = e.occlusionColor;
        edgeSurface.signedDistance = distEdges;

        // objects
        float distObjects = 1000.0;
        float maxDistObjects = 1000.0;
        // Surface objectSurface = Surface(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 10.0, 0.0, 0.5, 0.5, vec3(0.0, 0.0, 0.0), 1000.0);

        Surface objectSurface;
        objectSurface.color = float4(0.0, 0.0, 0.0, 0.0);
        objectSurface.ambientScale = 0.0;
        objectSurface.diffuseScale = 0.0;
        objectSurface.specularPow = 10;
        objectSurface.specularScale = 0.0;
        objectSurface.occlusionRange = 0.5;
        objectSurface.occlusionResolution = 0.5;
        objectSurface.occlusionColor = float3(0.0, 0.0, 0.0);
        objectSurface.signedDistance = 1000.0;


       
        
        for (int oI = 0; oI < OBJECT_COUNT; ++oI)
        {
            distObjects = 1000.0;
            

            // distObjects = poly_smin( distObjects, sphereSDF(GetLocalPositionFromTransformMatrix(pos,   o[oI].transform),  o[oI].size.x),  o[oI].smoothing );

            if (o[oI].primitive < 0)
            {
                //Do Nothing
            }
            else if (o[oI].primitive == 0) // sphere
            {
                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, sphereSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.x), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleSphereSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.x, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }

                
            }
            else if (o[oI].primitive == 1) // box
            {
                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, roundBoxSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size, o[oI].rounding), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleBoxSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size, o[oI].rounding, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }
            }
            else if (o[oI].primitive == 2) // capsule
            {
                distObjects = poly_smin(distObjects, roundCapsuleSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding), o[oI].smoothing); //________________________________________________ COPYYYYY------------------------------
            }
            else if (o[oI].primitive == 3) // cylinder
            {

                if (o[oI].amplitude.x == 0 && o[oI].amplitude.y == 0 && o[oI].amplitude.z == 0) // non-rippling
                {
                    distObjects = poly_smin(distObjects, roundCylinderSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding), o[oI].smoothing);
                }
                else
                {
                    distObjects = poly_smin(distObjects, rippleCylinderSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform), o[oI].size.z, o[oI].size.x, o[oI].rounding, o[oI].frequency, o[oI].amplitude, o[oI].phase), o[oI].smoothing);
                }
            }
            else if (o[oI].primitive == 4) // truchetTower (nothing) CHECK WITH DANI
            {
                distObjects = poly_smin(distObjects, truchetTower(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.z * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 5) // apollonian1 OK BIT NOISY
            {
                distObjects = poly_smin(distObjects, apollonian1(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.z * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 6) // Thing2 OK
            {
                distObjects = poly_smin(distObjects, Thing2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 7) // kaliBox SCALED IN FUNCTION (CANNOT SEE A THING)
            {
                distObjects = poly_smin(distObjects, kaliBox(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 8) // mandelbulb OK
            {
                distObjects = poly_smin(distObjects, mandelbulb_v2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.002, o[oI].size * 0.01), o[oI].smoothing) / 0.002;
            }
            else if (o[oI].primitive == 9) // merger SCALED IN FUNCTION (CANNOT SEE A THING)
            {
                distObjects = poly_smin(distObjects, merger(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 10) // sierpinskiPyramid ok
            {
                distObjects = poly_smin(distObjects, sierpinskiPyramid(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 11) // mengerSponge OK
            {
                distObjects = poly_smin(distObjects, mengerSponge(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 12) // alteredMenger SCALED IN FUNCTION (CANNOT SEE A THING)
            {
                distObjects = poly_smin(distObjects, alteredMenger(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.001), o[oI].smoothing) / 0.001;
            }
            else if (o[oI].primitive == 13) // evolvingFractal OK
            {
                distObjects = poly_smin(distObjects, evolvingFractal(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 14) // evolvingFractal2 OK
            {
                distObjects = poly_smin(distObjects, evolvingFractal2(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01), o[oI].smoothing) / 0.01;
            }
            else if (o[oI].primitive == 15) // OCTAFOLD COMMENTED
            {
                distObjects = poly_smin(distObjects, mandelbulbSDF(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size.x * 0.01), o[oI].smoothing) / 0.01;
                // distObjects = poly_smin( distObjects, octaFold(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.008), o[oI].smoothing )/ 0.008; 
            }
            else if (o[oI].primitive == 16) // julia ok??
            {
                distObjects = poly_smin(distObjects, julia(GetLocalPositionFromTransformMatrix(pos, o[oI].transform) * 0.01, o[oI].size * 0.01), o[oI].smoothing) / 0.01;
            }
            
            // Surface tmpSurface;
            // tmpSurface.color = o[oI].color; 
            // tmpSurface.ambientScale = o[oI].ambientScale;
            // tmpSurface.diffuseScale = o[oI].diffuseScale;
            // tmpSurface.specularPow = o[oI].specularPow;
            // tmpSurface.specularScale = o[oI].specularScale;
            // tmpSurface.occlusionScale = o[oI].occlusionScale;
            // tmpSurface.occlusionRange = o[oI].occlusionRange;
            // tmpSurface.occlusionResolution = o[oI].occlusionResolution;
            // tmpSurface.occlusionColor = o[oI].occlusionColor;
            // tmpSurface.signedDistance = distObjects;


            Surface tmpSurface;
            tmpSurface.color = float4(o[oI].color, 1.0);
            tmpSurface.ambientScale = o[oI].ambientScale;
            tmpSurface.diffuseScale = o[oI].diffuseScale;
            tmpSurface.specularPow = o[oI].specularPow;
            tmpSurface.specularScale = o[oI].specularScale;
            tmpSurface.occlusionScale = o[oI].occlusionScale;
            tmpSurface.occlusionRange = o[oI].occlusionRange;
            tmpSurface.occlusionResolution = o[oI].occlusionResolution;
            tmpSurface.occlusionColor = o[oI].occlusionColor;
            tmpSurface.signedDistance = distObjects;
            
            objectSurface = union_surface(tmpSurface, objectSurface, o[oI].smoothing);
            
            if (maxDistObjects > distObjects)
            {
                maxDistObjects = distObjects;
            }
        }


        // combined surface
        Surface skelEdgeSurface = union_surface(jointSurface, edgeSurface, jointEdgeSmoothing);

        Surface closestSurface;

        // closestSurface = skelEdgeSurface; // TAKE AWAY WITH OBJECTSsS__________!_!_!_!__!_!_

        if (maxDistObjects < 1000.0)
        {
            closestSurface = union_surface(skelEdgeSurface, objectSurface, skelObjectSmoothing);
        }
        else
        {
            closestSurface = skelEdgeSurface;
        }

        return closestSurface;
    }

    

    float3 GetLocalPositionFromTransformMatrix(float3 p, float4x4 transform)
    {
        float4x4 translation;

        translation._11_21_31_41 = float4(1.0, 0.0, 0.0, 0.0);
        translation._12_22_32_42 = float4(0.0, 1.0, 0.0, 0.0);
        translation._13_23_33_43 = float4(0.0, 0.0, 1.0, 0.0);
        translation._14_24_34_44 = transform._14_24_34_44;

        float4x4 rotation;

        rotation._11_21_31_41 = transform._11_21_31_41;
        rotation._12_22_32_42 = transform._12_22_32_42;
        rotation._13_23_33_43 = transform._13_23_33_43;
        rotation._14_24_34_44 = float4(0.0, 0.0, 0.0, 1.0);

        float3 localP = mul(inverse(rotation), mul(translation, float4(p, 1.0))).xyz;

        return localP;
    }

    float4x4 inverse(float4x4 m)
    {
        float3x3 rot = float3x3(m[0].xyz, m[1].xyz, m[2].xyz);
        float3x3 rotInv = transpose(rot);
        float3 trans = m[3].xyz;
        
        float4x4 inv;
        inv[0] = float4(rotInv[0], 0.0);
        inv[1] = float4(rotInv[1], 0.0);
        inv[2] = float4(rotInv[2], 0.0);
        inv[3] = float4(-mul(rotInv, trans), 1.0);
    
        return inv;
    }


    //Sphere
    float sphereSDF(float3 p, float r)
    {
        return length(p) - r;
    }
    // Sphere Ripple
    float rippleSphereSDF(float3 pos, float radius, float3 frequencies, float3 amplitudes, float3 phases)
    {
        float3 normPos = normalize(pos);

        float3 axisAlign = normPos;

        float3 surfaceDeformShape = float3(cos(axisAlign.x * frequencies.x + phases.x), cos(axisAlign.y * frequencies.y + phases.y), cos(axisAlign.z * frequencies.z + phases.z));

        float3 surfaceDeformScale = float3(1.0 - abs(axisAlign.x), 1.0 - abs(axisAlign.y), 1.0 - abs(axisAlign.z)) * amplitudes;

        float3 surfaceDeform = surfaceDeformShape * surfaceDeformScale;

        return length(pos) - radius + length(surfaceDeform);
    }

    float boxSDF(float3 p, float3 size)
    {
        float3 d = abs(p) - (size / 2.0);
        
        // Assuming p is inside the cube, how far is it from the surface?
        // Result will be negative or zero.
        float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
        
        // Assuming p is outside the cube, how far is it from the surface?
        // Result will be positive or zero.
        float outsideDistance = length(max(d, 0.0));
        
        return insideDistance + outsideDistance;
    }

    // Box
    float roundBoxSDF(float3 p, float3 size, float radius)
    {
        float3 d = abs(p) - ((size - radius) / 2.0);
        
        // Assuming p is inside the cube, how far is it from the surface?
        // Result will be negative or zero.
        float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
        
        // Assuming p is outside the cube, how far is it from the surface?
        // Result will be positive or zero.
        float outsideDistance = length(max(d, 0.0));
        
        return insideDistance + outsideDistance - radius;
    }

    // Box Ripple
    float rippleBoxSDF(float3 pos, float3 size, float radius, float3 frequencies, float3 amplitudes, float3 phases)
    {
        float3 normPos = float3(clamp(pos.x, -size.x / 2, size.x / 2) / size.x, clamp(pos.y, -size.y / 2, size.y / 2) / size.y, clamp(pos.z, -size.z / 2, size.z / 2) / size.z);

        float3 surfaceDeformShape = float3(0.0, 0.0, 0.0);
        surfaceDeformShape.y += cos(normPos.x * frequencies.x + phases.x);
        surfaceDeformShape.z += cos(normPos.x * frequencies.x + phases.x);
        surfaceDeformShape.x += cos(normPos.y * frequencies.y + phases.y);
        surfaceDeformShape.z += cos(normPos.y * frequencies.y + phases.y);
        surfaceDeformShape.x += cos(normPos.z * frequencies.z + phases.z);
        surfaceDeformShape.y += cos(normPos.z * frequencies.z + phases.z);

        float3 surfaceDeform = surfaceDeformShape * amplitudes;

        float3 d = abs(pos) - ((size + surfaceDeform - radius) / 2.0);
        
        // Assuming p is inside the cube, how far is it from the surface?
        // Result will be negative or zero.
        float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
        
        // Assuming p is outside the cube, how far is it from the surface?
        // Result will be positive or zero.
        float outsideDistance = length(max(d, 0.0));
        
        return insideDistance + outsideDistance - radius;
    }


    // Capsule (XY aligned, height h and radius r)
    float roundCapsuleSDF(float3 p, float h, float r, float radius)
    {
        p.z -= clamp(p.z, -(h - radius) / 2.0, (h - radius) / 2.0);
        return length(p) - r - radius;
    }

    // Cylinder(XY aligned, height h and radius r)
    float roundCylinderSDF(float3 p, float h, float r, float radius)
    {
        // How far inside or outside the cylinder the point is, radially
        float inOutRadius = length(p.xy) - (r - radius);
        
        // How far inside or outside the cylinder is, axially aligned with the cylinder
        float inOutHeight = abs(p.z) - (h - radius) / 2.0;
        
        // Assuming p is inside the cylinder, how far is it from the surface?
        // Result will be negative or zero.
        float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);

        // Assuming p is outside the cylinder, how far is it from the surface?
        // Result will be positive or zero.
        float outsideDistance = length(max(float2(inOutRadius, inOutHeight), 0.0));
        
        return insideDistance + outsideDistance - radius;
    }

    // Cylinder Ripple
    float rippleCylinderSDF(float3 pos, float height, float r, float radius, float3 frequencies, float3 amplitudes, float3 phases)
    {
        //vec3 normPos = vec3(clamp(pos.x, -radius, radius) / radius, clamp(pos.y, -radius, radius) / radius, clamp(pos.z, -height/2, height/2) / (height / 2));

        float3 normPos = float3(normalize(pos).x, normalize(pos).y, clamp(pos.z, -height / 2, height / 2) / (height / 2));

        float3 surfaceDeformShape = float3(0.0, 0.0, 0.0);

        surfaceDeformShape.x += cos(normPos.z * frequencies.z + phases.z);
        surfaceDeformShape.x += cos(normPos.y * frequencies.y + phases.y);
        surfaceDeformShape.y += cos(normPos.x * frequencies.x + phases.x);
        surfaceDeformShape.y += cos(normPos.z * frequencies.z + phases.z);
        surfaceDeformShape.z += cos(normPos.x * frequencies.x + phases.x);
        surfaceDeformShape.z += cos(normPos.y * frequencies.y + phases.y);

        float3 surfaceDeformScale = amplitudes * 0.2;
        float3 surfaceDeform = surfaceDeformShape * surfaceDeformScale;

        // How far inside or outside the cylinder the point is, radially
        float inOutRadius = length(pos.xy) - (r - radius) + length(surfaceDeform.xy);

        // How far inside or outside the cylinder is, axially aligned with the cylinder
        float inOutHeight = abs(pos.z) - (height / 2.0 - radius) / 2.0 + surfaceDeform.z;
        
        // Assuming p is inside the cylinder, how far is it from the surface?
        // Result will be negative or zero.
        float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);

        // Assuming p is outside the cylinder, how far is it from the surface?
        // Result will be positive or zero.
        float outsideDistance = length(max(float2(inOutRadius, inOutHeight), 0.0));
        
        return insideDistance + outsideDistance - radius;
    }



    float3 estimateNormal(float3 p)
    {
        // return normalize(float3(
        //     sceneSDF(float3(p.x + EPSILON, p.y, p.z)) - sceneSDF(float3(p.x - EPSILON, p.y, p.z)),
        //     sceneSDF(float3(p.x, p.y + EPSILON, p.z)) - sceneSDF(float3(p.x, p.y - EPSILON, p.z)),
        //     sceneSDF(float3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(float3(p.x, p.y, p.z - EPSILON))
        // ));

        float center_dist = sceneSDF(float3(p.x, p.y, p.z));

        return normalize(float3(
            sceneSDF(float3(p.x + EPSILON, p.y, p.z)) - center_dist,
            sceneSDF(float3(p.x, p.y + EPSILON, p.z)) - center_dist,
            sceneSDF(float3(p.x, p.y, p.z + EPSILON)) - center_dist
        ));
    }

    float3 phongContribForLight(float3 p, float3 eye, float3 N, float3 lightPos, float3 diffuseColor, float diffuseScale, float3 specularColor, float specularScale, float specularPow)
    {
        //float3 N = estimateNormal(p);
        float3 L = normalize(lightPos - p);
        float3 V = normalize(eye - p);
        float3 R = normalize(reflect(-L, N));
        
        float dotLN = dot(L, N);
        float dotRV = dot(R, V);
        
        if (dotLN < 0.0)
        {
            // Light not visible from this point on the surface
            return float3(0.0, 0.0, 0.0);
        }
        
        if (dotRV < 0.0)
        {
            // Light reflection in opposite direction as viewer, apply only diffuse
            // component
            return diffuseScale * (diffuseColor * dotLN);
        }
        return diffuseScale * diffuseColor * dotLN + specularScale * specularColor * pow(dotRV, specularPow);
    }

    //From Paul Hubert!
    float doAoSSS(float3 p, float3 n, float steps, float delta)
    {
        float a = 0.0;
        float weight = .5;
        for (float i = 1; i <= steps; i += 1)
        {
            float d = (i / steps) * delta;
            a = a + weight * (d - sceneSDF(p + n * d));
                // a = a + weight * (d - sceneSDF((p + n * d) * 0.01) / 0.01);
            weight = weight * 0.6;
        }
        return clamp(1.0 - a, 0.0, 1.0);
    }

    //DANI's Version
    float ambientOcclusion(float3 surfacePos, float3 surfaceNormal, float occlusionRange, float occlusionResolution)
    {
        
        float minT = 0.01;
        float maxT = occlusionRange;
        float tIncr = occlusionResolution;
        
        float occlusionFacor = 1.0;
        float dist;
        
        for (float t = minT; t < maxT; t += tIncr)
        {
            dist = sceneSDF(surfacePos + surfaceNormal * t);
            
            if (dist < t - EPSILON)
            {
                float normT = (t - minT) / (maxT - minT);
                occlusionFacor = occlusionFacor * normT + occlusionFacor * dist / t * (1.0 - normT);
            }
            
            if (occlusionFacor <= 0.0)
            {
                break;
            }
        }
        
        return occlusionFacor;
    }

    float hardShadow(float3 lightPoint, float3 lightToSurfaceDir, float mint, float maxt)
    {
        for (float t = mint; t < maxt;)
        {
            float h = sceneSDF(lightPoint + lightToSurfaceDir * t);
            if (h < 0.002)
                return 0.0;
            t += h;
        }
        return 1.0;
    }


    float softShadow(float3 lightPoint, float3 lightToSurfaceDir, float mint, float maxt, float k)
    {
        float res = 1.0;

        for (float t = mint; t < maxt;)
        {
            float h = sceneSDF(lightPoint + lightToSurfaceDir * t);
            if (h < 0.002)
                return 0.0;

            res = min(res, k * h / t);

            t += clamp(h, 0.02, 0.04);

            t += h / 10.0;
        }
        return res;
    }



    float shortestDistanceToSurface(float3 eye, float3 marchingDirection, float start, float end)
    {
        float depth = start;
        for (int i = 0; i < MAX_MARCHING_STEPS; i++)
        {
            float3 pos = eye + (marchingDirection * depth);

            float dist = sceneSDF(eye + depth * marchingDirection);
            if (dist < EPSILON)
            {
                return depth;
            }
            depth += dist;
            if (depth >= end)
            {
                return end;
            }
        }
        return end;
    }

    Surface shortestDistanceToSurface_surface(float3 eye, float3 marchingDirection, float start, float end)
    {

        //CHANGES NOISE
        // float depth = e.dithering * noise;


        Surface closestSurface;
        float depth = start;


        for (int i = 0; i < MAX_MARCHING_STEPS; i++)
        {
            closestSurface = sceneSDF_surface(eye + depth * marchingDirection);

            if (closestSurface.signedDistance < EPSILON)
            {
                closestSurface.signedDistance = depth;
                return closestSurface;
            }

            depth += closestSurface.signedDistance;

             //Checking Scene depth (it does not really work if the objects are really scaled scale)
            if (bg_on == 0)
            {
                if (depth > sceneDepth)
                {
                    closestSurface.signedDistance = end;
                    closestSurface.color = float4(bgColor.r, bgColor.g, bgColor.b, bg_on);
                    return closestSurface;
                }
            }

            if (depth >= end)
            {
                closestSurface.signedDistance = end;
                closestSurface.color = float4(bgColor.r, bgColor.g, bgColor.b, bg_on);
                
                return closestSurface;
            }

           

            
        }
        
        closestSurface.color = float4(bgColor, 1.0);
        closestSurface.ambientScale = 1.0;
        closestSurface.diffuseScale = 0.0;
        closestSurface.specularScale = 0.0;
        closestSurface.specularPow = 1.0;
        closestSurface.occlusionScale = 0.0;
        closestSurface.occlusionRange = 1.0;
        closestSurface.occlusionResolution = 1.0;
        // closestSurface.occlusionColor = bgOcclusionColor;
        closestSurface.occlusionColor = bgColor;
        closestSurface.signedDistance = end;
        
        return closestSurface;
    }

};

float4x4 viewMatrix(float3 eye, float3 center, float3 up)
{
    // Based on gluLookAt man page
    float3 f = normalize(center - eye);
    float3 s = normalize(cross(f, up));
    float3 u = cross(s, f);
    return float4x4(
        float4(s, 0.0),
        float4(u, 0.0),
        float4(-f, 0.0),
        float4(0.0, 0.0, 0.0, 1)
    );
}

float3 rayDirection(float fieldOfView, float2 fragCoord)
{
    float z = 1.0 / tan(radians(fieldOfView) / 2.0);
    return normalize(float3(fragCoord, -z));
}


[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void SimpleComputeShader(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint GroupIndex : SV_GroupIndex )
{
	//Initialize
    float CameraAngle = 30;
    float3 CameraPosition = float3(0.001, -650, 0.001);
    

    
    
    //TEXTURE!
    int x = 0;
    int y = 0;
    myfunctions f = (myfunctions) 0;
//f.myTime = myTime;
//f.sceneDepth = sceneDepth;

    //float tmpValue = 0.0;
    
    //tmpValue = DataTexture.Load(int3(x++, y, 0)).r;
    //f.bgColor.r = isnan(tmpValue) ? 0.0 : tmpValue;
   
    f.bgColor.r = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  RED
    //f.bgColor.r = isnan(f.bgColor.r) ? 0.0 : f.bgColor.r;
    
    f.bgColor.g = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  GREEN
    f.bgColor.b = DataTexture.Load(int3(x++, y, 0)).r; // COLOR BLUE
    f.bg_on = DataTexture.Load(int3(x++, y, 0)).r;

    f.lightPosition.x = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  RED
    f.lightPosition.y = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  GREEN
    f.lightPosition.z = DataTexture.Load(int3(x++, y, 0)).r; // COLOR BLUE

    f.jointEdgeSmoothing = DataTexture.Load(int3(x++, y, 0)).r;
    f.skelObjectSmoothing = DataTexture.Load(int3(x++, y, 0)).r;

    f.shadowStrength = DataTexture.Load(int3(x++, y, 0)).r;
    f.shadowSmooth = DataTexture.Load(int3(x++, y, 0)).r;

    f.dithering = DataTexture.Load(int3(x++, y, 0)).r;

    f.fog_min_dist = DataTexture.Load(int3(x++, y, 0)).r;
    f.fog_max_dist = DataTexture.Load(int3(x++, y, 0)).r;;

    CameraPosition.x = DataTexture.Load(int3(x++, y, 0)).r;
    CameraPosition.y = DataTexture.Load(int3(x++, y, 0)).r;
    CameraPosition.z = DataTexture.Load(int3(x++, y, 0)).r;
    
    CameraAngle = DataTexture.Load(int3(x++, y, 0)).r;

    float3 viewDir = rayDirection(CameraAngle, DispatchThreadId.xy);
    float3 eye = CameraPosition;
    float4x4 viewToWorld = viewMatrix(eye, float3(0.0, 0.0, 0.0), float3(0.0, 0.0, -1.0));
    float3 worldDir = (mul(viewToWorld, float4(viewDir, 0.0))).xyz;
    

    uint2 odim;
    DataTexture.GetDimensions(odim.x, odim.y);

    myjointvalues j;
    x = 0;
    y += 1; //1

    j.color.r = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  RED
    j.color.g = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  GREEN
    j.color.b = DataTexture.Load(int3(x++, y, 0)).r; // COLOR BLUE
    j.ambientScale = DataTexture.Load(int3(x++, y, 0)).r; // AMBIENT SCALE
    j.diffuseScale = DataTexture.Load(int3(x++, y, 0)).r; //DIFFUSE SCALE
    j.specularScale = DataTexture.Load(int3(x++, y, 0)).r; // SPECULAR SCALE
    j.specularPow = DataTexture.Load(int3(x++, y, 0)).r; // SPECULAR POW
    j.occlusionScale = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION SCALE
    j.occlusionRange = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION RANGE
    j.occlusionResolution = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION RESOLUTION
    j.occlusionColor.r = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR RED
    j.occlusionColor.g = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR GREEN
    j.occlusionColor.b = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR BLUE

    y += 1; //2

    for (x = 0; x < JOINT_COUNT; x++)
    {
        j.primitives[x] = DataTexture.Load(int3(x, y, 0)).r;
    // j.primitives[x] = 1;
    }

    y += 1; //3

    for (x = 0; x < JOINT_COUNT; x++)
    {
        j.roundings[x] = DataTexture.Load(int3(x, y, 0)).r;
    // j.roundings[x] = 0.0;
    }

    y += 1; //4

    for (x = 0; x < JOINT_COUNT; x++)
    {
        j.smoothings[x] = DataTexture.Load(int3(x, y, 0)).r;
    // j.smoothings[x] = 0.1;
    }

    y += 1; //5

    float4x4 Identity =
    {
        { 1, 0, 0, 0 },
        { 0, 1, 0, 0 },
        { 0, 0, 1, 0 },
        { 0, 0, 0, 1 }
    };
    float4x4 tempTransform;
    for (x = 0; x < JOINT_COUNT; x++)
    {

    // j.transforms[x] = Identity;
        for (int d = 0; d < 4; d++)
        {
            float4 sampledColorMatrixColumn = DataTexture.Load(int3(x * 4 + d, y, 0));

            tempTransform[0][d] = sampledColorMatrixColumn.r;
            tempTransform[1][d] = sampledColorMatrixColumn.g;
            tempTransform[2][d] = sampledColorMatrixColumn.b;
            tempTransform[3][d] = sampledColorMatrixColumn.a;

        
        }

        j.transforms[x] = tempTransform;
    }

    y += 1; //6

    for (x = 0; x < JOINT_COUNT; x++)
    {
        j.sizes[x] = DataTexture.Load(int3(x, y, 0)).rgb;
    // j.sizes[x] = float3(10, 10, 10);
    }

    y += 1; //7
    x = 0;

    myedgevalues e;
    e.color.r = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  RED
    e.color.g = DataTexture.Load(int3(x++, y, 0)).r; // COLOR  GREEN
    e.color.b = DataTexture.Load(int3(x++, y, 0)).r; // COLOR BLUE
    e.ambientScale = DataTexture.Load(int3(x++, y, 0)).r; // AMBIENT SCALE
    e.diffuseScale = DataTexture.Load(int3(x++, y, 0)).r; //DIFFUSE SCALE
    e.specularScale = DataTexture.Load(int3(x++, y, 0)).r; // SPECULAR SCALE
    e.specularPow = DataTexture.Load(int3(x++, y, 0)).r; // SPECULAR POW
    e.occlusionScale = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION SCALE
    e.occlusionRange = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION RANGE
    e.occlusionResolution = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION RESOLUTION
    e.occlusionColor.r = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR RED
    e.occlusionColor.g = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR GREEN
    e.occlusionColor.b = DataTexture.Load(int3(x++, y, 0)).r; // OCCLUSION COLOR BLUE

    y += 1; //8

    for (x = 0; x < EDGE_COUNT; x++)
    {
        e.primitives[x] = DataTexture.Load(int3(x, y, 0)).r;
    }

    y += 1; //9

    for (x = 0; x < EDGE_COUNT; x++)
    {
        e.roundings[x] = DataTexture.Load(int3(x, y, 0)).r;
    }

    y += 1; //10

    for (x = 0; x < EDGE_COUNT; x++)
    {
        e.smoothings[x] = DataTexture.Load(int3(x, y, 0)).r;
    }

    y += 1; //11

    for (x = 0; x < EDGE_COUNT; x++)
    {
        for (int d = 0; d < 4; d++)
        {
            float4 sampledColorMatrixColumn = DataTexture.Load(int3(x * 4 + d, y, 0));

            tempTransform[0][d] = sampledColorMatrixColumn.r;
            tempTransform[1][d] = sampledColorMatrixColumn.g;
            tempTransform[2][d] = sampledColorMatrixColumn.b;
            tempTransform[3][d] = sampledColorMatrixColumn.a;
        }
        e.transforms[x] = tempTransform;
    }

    y += 1; //12

    for (x = 0; x < EDGE_COUNT; x++)
    {
        e.sizes[x] = DataTexture.Load(int3(x, y, 0)).rgb;
    // e.sizes[x] = DataTexture.Load(int3(x , y , 0 )).rgb; 
    }

    y += 1; //13

    myobjectvalues o[OBJECT_COUNT];
    int insideCounter = 0;
    int startPixel = y;
    int finnish = y + OBJECT_COUNT;
//OBJECTS
    for (y = startPixel; y < finnish; y++)
    {
        x = 0;
    
        o[insideCounter].color.r = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].color.g = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].color.b = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].primitive = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].rounding = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].smoothing = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].amplitude.x = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].amplitude.y = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].amplitude.z = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].frequency.x = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].frequency.y = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].frequency.z = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].phase.x = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].phase.y = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].phase.z = DataTexture.Load(int3(x++, y, 0)).r;

        o[insideCounter].ambientScale = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].diffuseScale = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].specularScale = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].specularPow = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionScale = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionRange = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionResolution = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionColor.r = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionColor.g = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].occlusionColor.b = DataTexture.Load(int3(x++, y, 0)).r;
    
        o[insideCounter].transform[0][0] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[1][0] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[2][0] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[3][0] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[0][1] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[1][1] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[2][1] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[3][1] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[0][2] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[1][2] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[2][2] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[3][2] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[0][3] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[1][3] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[2][3] = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].transform[3][3] = DataTexture.Load(int3(x++, y, 0)).r;

        o[insideCounter].size.x = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].size.y = DataTexture.Load(int3(x++, y, 0)).r;
        o[insideCounter].size.z = DataTexture.Load(int3(x++, y, 0)).r;

        insideCounter++;
    }

    f.j = j;
    f.e = e;
    f.o = o;

// float ditherNoise = texCUBElod(noiseCubemapSampler, float4(RayDirection, 0)).r;
// Surface surface = f.shortestDistanceToSurface_surface(CameraPosition, RayDirection, MIN_DIST, MAX_DIST, ditherNoise);
    Surface surface = f.shortestDistanceToSurface_surface(CameraPosition, worldDir, MIN_DIST, MAX_DIST);
    float dist = surface.signedDistance;

    if (dist > MAX_DIST - EPSILON)
    {
    // Didn't hit anything
        RenderTarget[DispatchThreadId.xy] = float4(surface.color.rgb, 1.0).rgb;
        return;
    }

//SURFACE

// regular lighting    
    // The closest point on the surface to the eyepoint along the view ray
    float3 p = CameraPosition + dist * worldDir;

    float3 color1 = surface.color.rgb * surface.ambientScale;

// SHADOW implementation
    float lightStrength = 1;
    if (f.shadowStrength > 1)
    {
        float3 lightToSurfaceVec = p - f.lightPosition;
        float lightToSurfaceDist = length(lightToSurfaceVec);
        float3 lightToSurfaceDir = normalize(lightToSurfaceVec);
        lightStrength = f.softShadow(f.lightPosition, normalize(lightToSurfaceVec), 0.0, length(lightToSurfaceVec) - 100, f.shadowSmooth);
        lightStrength = (1.0 - f.shadowStrength) + lightStrength * f.shadowStrength;
    }
    float3 surfacePos = p;
    float3 surfaceNormal = f.estimateNormal(surfacePos);

    color1 += f.phongContribForLight(p, CameraPosition, surfaceNormal, f.lightPosition, surface.color.rgb, surface.diffuseScale, surface.color.rgb, surface.specularScale, surface.specularPow) * lightStrength;
    //color1 += f.phongContribForLight(p, CameraPosition, f.lightPosition, surface.color, surface.diffuseScale, surface.color, surface.specularScale, surface.specularPow) * lightStrength;

// ambient occlusion
    float3 colorDiff = color1 - surface.occlusionColor;

// float3 surfaceNormal = f.estimateNormal(surfacePos);
// float occlusionStrength = f.ambientOcclusion(surfacePos, surfaceNormal, surface.occlusionRange, surface.occlusionResolution);
    float occlusionStrength = f.doAoSSS(surfacePos, surfaceNormal, surface.occlusionRange, surface.occlusionResolution);
    occlusionStrength = 1.0 - occlusionStrength;
    occlusionStrength *= surface.occlusionScale;

    float3 color2 = float3(color1.r - occlusionStrength * colorDiff.r, color1.g - occlusionStrength * colorDiff.g, color1.b - occlusionStrength * colorDiff.b);

    float fog_dist = clamp((dist - f.fog_min_dist) / (f.fog_max_dist - f.fog_min_dist), 0.0, 1.0);
    float3 color3 = fog_dist * f.bgColor + (1.0 - fog_dist) * color2;

    //return float4(color3, 1.0);
    
    

    //float3 dir = rayDirection(45.0, float2(1024, 1024), DispatchThreadId.xy);
    //float3 eye = float3(0.0, 0.0, 5.0);
    //float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);
    
    //if (dist > MAX_DIST - EPSILON)
    //{
    //// Didn't hit anything
    //    RenderTarget[DispatchThreadId.xy] = float3(0.0, 0.0, 0.0);
    //    return;
    //}
    
    RenderTarget[DispatchThreadId.xy] = float4(color3, 1.0).rgb;

}